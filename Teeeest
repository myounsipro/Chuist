@Test
void syncWithIdp_shouldUpdateExistingUser_ifAuthoritiesDiffer() {
    Jwt jwt = mock(Jwt.class);
    Map<String, Object> claims = Map.of("claimKey", "claimValue");
    when(jwt.getClaims()).thenReturn(claims);

    // Prépare les autorités réelles
    Authority authorityUser = new Authority(new AuthorityName("ROLE_USER"));
    Authority authorityAdmin = new Authority(new AuthorityName("ROLE_ADMIN"));
    Set<Authority> authoritiesUser = Set.of(authorityUser);
    Set<Authority> authoritiesAdmin = Set.of(authorityAdmin);

    User incomingUser = mock(User.class);
    when(incomingUser.getEmail()).thenReturn("test@example.com");
    when(incomingUser.getAuthorities()).thenReturn(authoritiesUser);

    User existingUser = mock(User.class);
    when(existingUser.getAuthorities()).thenReturn(authoritiesAdmin);

    when(userRepository.getOneByEmail("test@example.com"))
            .thenReturn(Optional.of(existingUser));

    try (
        MockedStatic<AuthenticatedUser> staticAuth = mockStatic(AuthenticatedUser.class);
        MockedStatic<User> staticUser = mockStatic(User.class)
    ) {
        staticAuth.when(() ->
            AuthenticatedUser.extractAuthoritiesFromAttributes(claims)
        ).thenReturn(List.of("ROLE_USER"));

        staticUser.when(() ->
            User.fromTokenUserInfo(any(), eq(List.of("ROLE_USER")))
        ).thenReturn(incomingUser);

        userSynchronizer.syncWithIdp(jwt, claims);
    }

    verify(existingUser).updateFromUser(incomingUser, authoritiesUser);
    verify(userRepository).save(existingUser);
}