import { ComponentFixture, TestBed } from '@angular/core/testing';
import { FilteredInvoiceComponent } from './filtered-invoice.component';
import { of, throwError } from 'rxjs';
import { InvoiceService } from 'src/app/shared/service/invoice.service';
import { SnackbarPFService } from 'src/app/shared/service/snackbar-pf.service';

describe('FilteredInvoiceComponent', () => {
  let component: FilteredInvoiceComponent;
  let fixture: ComponentFixture<FilteredInvoiceComponent>;
  let mockInvoiceService: any;
  let mockSnackbar: any;

  beforeEach(async () => {
    mockInvoiceService = {
      getFilteredInvoices: jest.fn()
    };

    mockSnackbar = {
      error: jest.fn(),
      warn: jest.fn()
    };

    await TestBed.configureTestingModule({
      declarations: [FilteredInvoiceComponent],
      providers: [
        { provide: InvoiceService, useValue: mockInvoiceService },
        { provide: SnackbarPFService, useValue: mockSnackbar }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(FilteredInvoiceComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should fetch invoices and update state on success', () => {
    const mockResponse = { invoices: [{ id: 1 }] };
    mockInvoiceService.getFilteredInvoices.mockReturnValue(of(mockResponse));

    component.searchInvoices();

    expect(mockInvoiceService.getFilteredInvoices).toHaveBeenCalledWith(component.filters);
    expect(component.invoices()).toEqual(mockResponse.invoices);
    expect(mockSnackbar.warn).not.toHaveBeenCalled();
  });

  it('should show warning if no invoices are returned', () => {
    const mockResponse = { invoices: [] };
    mockInvoiceService.getFilteredInvoices.mockReturnValue(of(mockResponse));

    component.searchInvoices();

    expect(mockSnackbar.warn).toHaveBeenCalledWith(
      "Aucune facture n'a été trouvée pour les critères choisis !",
      false,
      'warning'
    );
  });

  it('should handle error and show snackbar', () => {
    const error = new Error('Backend error');
    mockInvoiceService.getFilteredInvoices.mockReturnValue(throwError(() => error));

    component.searchInvoices();

    expect(mockSnackbar.error).toHaveBeenCalledWith(
      'Error during fetching invoices.',
      false,
      'error'
    );
  });
});




it('should call documentService.downloadExcel and saveAs the file', () => {
  const blob = new Blob(['test'], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const spySaveAs = jest.spyOn(require('file-saver'), 'saveAs');

  const invoiceId = 123;
  const invoiceNumber = 'INV-001';
  const invoiceVersion = 1;
  const expectedFilename = `invoice_${invoiceId}_${invoiceNumber}_${invoiceVersion}.xlsx`;

  component['documentService'] = {
    downloadExcel: jest.fn().mockReturnValue(of(blob))
  } as any;

  component.downloadInvoice(invoiceId, invoiceNumber, invoiceVersion);

  expect(component['documentService'].downloadExcel).toHaveBeenCalledWith(invoiceId);
  expect(spySaveAs).toHaveBeenCalledWith(blob, expectedFilename);
});





it('should call downloadZip with filtered invoice IDs and save the result', () => {
  const blob = new Blob(['zipdata'], { type: 'application/zip' });
  const spySaveAs = jest.spyOn(require('file-saver'), 'saveAs');

  const invoiceList = [{ id: 1 }, { id: 2 }];
  component.invoices.set(invoiceList as any);
  component['documentService'] = {
    downloadZip: jest.fn().mockReturnValue(of(blob))
  } as any;

  const now = new Date().toISOString().slice(0, 10);
  const expectedFilename = `Factures_${now}.zip`;

  component.downloadFilteredInvoices();

  expect(component.filteredInvoices).toEqual([1, 2]);
  expect(component['documentService'].downloadZip).toHaveBeenCalledWith([1, 2]);
  expect(spySaveAs).toHaveBeenCalledWith(blob, expectedFilename);
});





